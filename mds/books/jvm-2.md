# 垃圾收集器

-   [1. 确认对象存活的算法](#chapter3-1)
-   [2. 引用的类型](#chapter3-2)
-   [3. 细说对象死亡](#chapter3-3)

---

> 本文主要介绍了 JVM 如何选用垃圾收集算法和垃圾收集器

## <a id="chapter3-1">1. 确认对象存活的算法</a>

JVM 垃圾收集的前提是已经知道哪些对象是可以被垃圾回收器所回收，哪些是不能被回收的。那么 JVM 必然有一个可行的方案来判断对象是否已经“死亡”。

下面有两个算法是各个 JVM 通常会选用的方案：

-   引用计数算法：

    给对象中添加一个 **引用计数器**，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为 0 的对象就是不可能再被使用，也就是意味着这个对象 “死亡”。

-   可达性分析算法：

     通过一系列的称为 “GC Roots” 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Refence Chain），当一个对象到GC Roots没有任何引用链相连时，则证明此对象不可用。

> HotSopt 中使用的是可达性分析算法。

## <a id="chapter3-2">2. 引用的类型</a>

什么！？引用还有类型！！在原来的理解中，一直认为只要对象与 “GC Roots” 之间有引用链相连就不会被垃圾收集器回收。事实上，有很多种引用在与 “GC Roots” 之间有引用链相连时也会被回收。

下面来介绍下 4 种引用类型：

1.  强引用（**Strong Reference**）
    
    使用 new 创建对象时，被创建的对象就是强引用。比如：Object obj = new Object()。只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。

1.  软引用（**Soft Reference**）

    描述一些还有用但并非必须的对象。软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中，进行第二次回收。如果这次回收之后内存还是不足，才会抛出内存溢出异常。

1.  弱引用（**Weak Reference**）

    强度比软引用更弱一点。被弱引用关联的对象只能生存到下一次垃圾收集发生之前。也就是说，不管内存空间充足与否，都会将其回收。

1.  虚引用（**Phantom Reference**）

    最弱的一种引用关系。唯一目的：对象被收集器回收时，收到一个系统通知。

## <a id="chapter3-3">3. 细说对象死亡</a>

上面已经说到了引用类型，有些引用类型即使还存活却还是会被垃圾回收器所回收。那么，对象在被回收之前会经历那些事情呢？