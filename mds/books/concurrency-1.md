#   volatile 与 synchronized 锁的四种状态

1.  <a id="c-1">volatile</a>
1.  <a id="c-2">synchronized 锁的四种状态</a>

---

## <a id="c-1">1. volatile</a>

### 1.1 概念

-   缓冲行：CPU 高速缓存中可以分配的最小存储单位。

-   原子操作：不可中断的一个或者一系列操作。

### 1.2 volatile 原理

被 volatile 修饰的变量进行 **写操作** 时，JVM 就会向处理器发送一条 **lock** 前缀的指令。接着，JVM 将这个变量所在 **缓存行** 的数据写会到系统内存。

同时，为了保证各个处理器的缓存一致性，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是否过期了。当处理器发现自己 **缓存行** 对应的内存地址被修改，就会将 **当前处理器** 的 **缓存行** 设置为无效状态。此时，如果当前处理器需要用到这个数据时，就会重新从系统内存中读取数据到当前处理器的缓存中。

### 1.3 volatile 总结

1.  Lock 前缀指令会引起处理器缓存写回到到内存。

1.  一个处理器的缓存写回到内存会导致其他处理器中的缓存无效。

##  <a id="c-2">2. synchronized 锁的四种状态</a>

synchronized 可以认为是重量级锁。但是，JVM 为了减少不必要的消耗，为 synchronized 提供了四种状态：无锁状态、偏向锁、轻量级锁和重量级锁。

### 2.1 Java 对象头结构

> synchronized 用的锁是存在 Java 对象头中。

熟悉 Java 虚拟机的人知道，Java 对象存储在堆中，对象引用存储在 Java 虚拟机栈中。

而对象在内存中存储的布局可以分为 3 块区域：

1.  对象头
1.  实例数据
1.  对齐填充

对象头分为两部分：

1.  Mark Word

1.  类型指针