# Book
![](../../imgs/jvm/jvm-book.jpg "《深入理解Java虚拟机 第2版》")

## 目录

- [Java内存区域与内存溢出异常](#OOM)
    - [运行时数据区域](../books/jvm-1.md)
    - [HotSpot虚拟机对象](#HOTSPOT-OBJ)
    - [总结](#OOM-SUMMARY)
- 垃圾收集器与内存分配策略
    - [垃圾收集器](../books/jvm-2.md)
    - [内存分配与回收策略](../books/jvm-3.md)
- [类文件结构](#CLASS-FILE-STRUCTURE)
- [虚拟机类加载机制](#CLASSLOADER)
    - [类加载的时机](#CLASS-LOAD-TIME)
    - [类加载的过程](#CLASS-LOAD-PROCESS)
    - [验证](#FILE-VALIDATION)
    - [准备](#FILE-PREPARE)
    - [解析](#FILE-ANALYSIS)
    - [初始化](#FILE-INIT)
    - [类加载器](#CLASSLOADER-MECHINE)
- [Java内存模型与线程](#MEMORY-MODEL-AND_THREAD)
    - [物理机的内存模型](#PHYSIC-MEMORY-MODEL)
    - [Java内存模型](#JAVA-MEMORY-MODEL)
    - [Java与线程](#JAVA-AND-THREAD)
- [线程安全和锁优化](#THREAD-SECURITY-AND-LOCK-OPTIMIZE)

# <a id="HOTSPOT-OBJ">HotSpot虚拟机对象</a>

### 创建对象（new指令）
- 检查这个指令的参数是否能在常量池中定位到一个类的符号引用。
- 检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，必须先执行相应的类加载过程。
- 类加载检查通过之后（其实对象所需的内存大小已经完全确定），JVM将为新生对象分配内存，此时一块确定大小的内存从Java堆中划分出来。
- Java堆的划分方式：选择哪种分配方式由**Java堆是否规整决定**
    - 指针碰撞(Bump the Pointer),假设Java堆中内存是**绝对规整**的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器。
    - 空闲列表(Free List),假设Java堆中的内存并**不是规整**的，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。

> 对象在内存中储存的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）、对齐填充（Padding）。

### 对象的内存布局
- HotSpot虚拟机的**对象头**包括2部分：
    - 第一部分，用于储存对象自身的运行时数据，哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID等。
    - 第二部分是类型指针，即对象指向它的类元数据的指针。虚拟机通过这个指针来确定这个对象是哪个类的实例。
    - 如果对象是一个Java数组，对象头中还有一块用于记录数组的长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中却无法确定数组的大小。

- **实例数据**，是对象真正储存的有效信息，也是在程序代码中所定义的各种类型的字段内容。

- **对齐填充**，并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。对于HotSpot VM要求对象的大小必须是8字节的整数倍。当对象实例数据部分没有对齐时，就需要通过对齐填充来不全。

### 对象的访问定位
- 主流的访问方式：句柄、直接指针。
    - **句柄**，Java堆中将会划分出一块内存作为句柄池，reference中储存的就是对象的句柄地址，而句柄中包含了类信息。
    ![句柄模型](../../imgs/jvm/jvm-2.png)
    - **直接指针**
    ![直接指针模型](../../imgs/jvm/jvm-3.png)
- 句柄与直接指针的优缺点:
    - 句柄：reference中储存的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要修改。
    - 直接指针：速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多也是一项非常可观的执行成本(HotSport是使用直接指针进行对象访问的)。

- HotSpot虚拟机中不区分虚拟机栈和本地方法栈。

# <a id="OOM-SUMMARY">总结</a>
- 程序计数器、虚拟机栈、本地方法栈3个区域随线程而生、随线程而灭。
- 栈中的每一个栈帧中分配的多少内存基本上是在类结构确定下来时就已知的。因此这几个区域的内存分配和回收都具备确定性，就不需要过多考虑回收的问题。

# <a id="CLASS-FILE-STRUCTURE">类文件结构</a>

-	Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中。
-	Class文件格式采用一种类似C语言结构体的伪结构来储存数据。
-	Class文件结构只有两种数据类型：无符号数、表。
-	无符号数：属于基本的数据类型，可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。

表：由多个无符号数和其他表作为数据项构成。

##	魔数
每个Class文件的头4个字节称为魔数，魔数唯一的作用就是确定这个文件是否为一个能被虚拟机接受的Class文件。

第5，6字节是次版本号（Minor Version），第7，8字节是主板本号（Major Version）。

##	常量池
紧接着主板本号之后的是常量池。

常量池中主要存放两大类常量：字面量和符号引用。

字面量包括：文本字符串、声明为final的常量值。
符号引用包括：
-   类和接口的全限定名。
-   字段的名称和描述符
-   方法的名称和描述符

##	访问标志
常量池之后，紧接着是访问标志。

访问标志用于识别一些类或者接口层次的访问信息，包括：这个class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final等。

##	类索引、父类索引与接口索引集合
Class文件中由这三项数据来确定这个类的继承关系。

##	字段表集合
字段表用于描述接口或者类中声明的变量。

字段包括类级变量和实例级变量，不包括方法内部的局部变量。

#   <a id="CLASS-LOAD-TIME">虚拟机类加载机制</a>

### 什么是虚拟机的类加载机制？

虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。

## 类加载的时机

类从类加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：

-   加载（Loading）
-   验证（Verification）
-   准备（Preparation）
-   解析（Resolution）
-   初始化（Initialization）
-   使用（Using）
-   卸载（Unloading）

其中，加载、验证、准备、初始化和卸载这5个阶段的顺序是 **确定** 的。但是，解析阶段则不一定：解析阶段在某些情况下，可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定。

![](../../imgs/jvm/jvm-17.png)

## 什么情况下需要开始类加载过程的第一个阶段：加载？

1.	遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果对应类没有进行初始化，则需要先加载该类。
    -	new：使用new关键字实例化对象的时候（仅第一次调用的时候）。
    -	getstatic：读取一个类的静态字段。
    -	putstatic：设置一个类的静态字段。（被final修饰、已在编译期把结果放入常量池的静态字段除外）。
    -	invokestatic：调用一个类的静态方法。    
2.	使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先加载该类。
3.	当初始化一个类的时候，如果发现其父类还没有进行初始化过程，则需要先触发其父类的初始化。
> 注意：接口与类初始化的唯一区别就是接口不一定要初始化父接口，只有在用到的时候才初始化。
4.	当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化这个主类。
5.	当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例后的解析结果

##	以下3种情况不会开始加载类

-	以子类为访问入口，去访问父类中的静态变量，此时子类不会加载。
-	初始化某个类的数组的时候，该类不会被加载。
-	访问类的静态常量(final)的时候，该类不会被加载。

# <a id="CLASS-LOAD-PROCESS">类加载的过程</a>

“加载”是“类加载”过程的一个阶段。

> 注意：加载阶段与连接阶段的部分内容是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。

###	加载阶段需要完成以下3件事情：
1.	通过一个类的全限定名（包名.外部类名$内部类名）来获取定义此类的二进制字节流。
    -  	从ZIP包中读取，最终成为日后JAR、EAR、WAR格式的基础。
    -	从网络中获取，典型的应用就是Applet。
    -	运行时计算生成，最多的就是动态代理技术，在java.lang.reflect.Proxy中，用了ProxtGenerator.generateProxyClass来为特定接口生成形式为“$*Proxy”的代理类的二进制字节流。
    -	JSP文件生成对应的Class类。
2.	将这个字节流所代表的静态储存结构转化为方法区的运行时数据结构。
3.	在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

####	数组类本身不通过类加载器创建，是由Java虚拟机直接创建的。
###	数组类创建过程需要遵循的规则：
1.	如果数组的组件类型（数组去掉一个维度的类型）是引用类型，就递归采用类加载过程去加载这个组件类。

    比如，Object[] a = new Object[10]; 其组件类型就是Object。

2.	如果数组的组件类型非引用类型。Java虚拟机将会把数组C标记为与引导类加载器关联。
    
    比如，Object[][] aa = new Object[10][10]；其组件类型就是Object[]，为非引用类型。

3.	数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为public。

#   <a id="FILE-VALIDATION">验证</a>

> 验证是连接阶段的第一步。

### 目的

为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，不会危害虚拟机自身的安全。

### 验证细节
从整体上看，验证分为4个阶段：文件格式验证、元数据验证、字节码验证、符号验证。

-   文件格式验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。
    这阶段的验证是基于 **二进制字节流** 进行的，只有通过了这个阶段的验证之后，字节流才会进入内存的方法区中进行储存。后面的3个验证阶段全部是基于方法区的储存结构进行的。
    -	是否以魔数0xCAFEBABE开头。
    -	主、次版本是否在当前虚拟机处理范围之外。

-	元数据验证：主要目的是对类的元数据信息进行语义校验，保证不存在不符合Java语言规范的元数据信息。
    -	这个类是否有父类
    -	这个类的父类是否集成了不允许被继承的类（被final修饰的类）

-	字节码验证  
    对类的方法体进行校验分析

-	符号验证：发生在虚拟机将符号引用转化为直接引用的时候。
    -	符号引用中通过字符串描述的全限定名是否能找到对应的类。
    -	符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被当前类访问。

###	总结
-	验证阶段非常重要，当不是一定必要的。
-	可以通过-Xverify:none参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。
-	验证阶段就是对一个class文件从文件的结构到方法内部结构的验证。

#   <a id="FILE-PREPARE">准备</a>

> 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段。

-   类变量使用的内存都将在方法区中分配。
-   假设一个类变量的定义为：
    
    `public static int value = 123;` 

    那变量value在准备阶段过后的初始值为 **0** 而不是 **123** ，因为此时尚未开始执行任何java方法，在初始化阶段才会执行value=123操作。

    但是有例外：    
    如果，变量被修饰成静态常量的时候，就会在准备阶段初始化。    
    `public static final int value = 123;`

#   <a id="FILE-ANALYSIS">解析</a>

>	解析阶段是虚拟机将常量池内的 **符号引用** 替换成 **直接引用** 的过程。

-	符号引用，以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义地定位到目标即可。
    
    在Java中，一个java类将会编译成一个class文件。在编译时，java类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。
与JVM实现的内存布局不相关。

-	直接引用，可以是直接指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。具体指向哪里，这与JVM实现的内存布局相关。

### 类或接口的解析

如果要把一个从未解析过的符号引用N解析为一个类或者接口C的直接引用，需要一下3个步骤

1.	如果C不是数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个C，在加载过程中，由于元数据验证、字节码验证的需要，有可能会触发其他相关类的加载动作。一旦这个过程出现了任何异常，解析过程就宣告失败。

2.	如果C是数组类型，并且数组的元素类型为对象，将会按照第一点的规则加载数组元素类型。接着虚拟机生成一个代表此数组维度和元素的数组对象。

3.	进行符号引用验证。

###	字段解析

将字段所属的类或者接口用C表示：

1.	如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。

2.	否则，如果在C中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。

3.	否则，如果C不是java.lang.Object的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。

4.	否则查找失败，抛出java.lang.NoSuchFieldError异常。

    **注意** ：在实际的应用中，虚拟机的编译器实现可能会比上面的规范还要严格。如果有一个同名字段同时出现在C的接口和父类中，或者同时在自己或者父类的多个接口中出现，那么编译期可能会拒绝编译。
 
###	类方法解析

C表示类。

1.	类方法和接口方法符号引用的常量类型定义是分开的。如果发现类方法表中发现 **class_index** 中的索引的C是接口，那么直接抛出java.lang.IncompatibleClassChangeError异常。

2.	过了第一步，查找C中是否有简单名称和描述符都与目标相匹配的方法。如果有直接返回这个方法的直接引用，查找结束。

3.	如果没有，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法。如果有则返回这个方法的直接引用，查找结束。

4.	如果没有，在类C实现的接口列表以及他们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在，说明C是一个抽象类，查找结束，抛出java.lang.IllegalAccessError异常。

5.	否则，方法查找失败，抛出java.lang.NoSuchMethodError。

###	接口方法解析

1.	如果在接口方法表中发现class_index中的索引C是个类，直接抛出java.lang.IncompatibleClassChangeError异常。

2.	否则在接口中查找是否有简单名称和描述符都与目标相匹配的方法，有的话直接返回这个方法的直接引用，查找结束。

3.	否则，在接口C的父接口中递归查找，直到java.lang.Object类（不包括Object类）为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有返回这个方法的直接引用，查找结束。

4.	否则，查找失败，抛出java.lang.NoSuchMethodError。

# <a id="FILE-INIT">初始化</a>

>	初始化，这个阶段是类加载的最后一步。

这个阶段才真正开始执行类中定义的Java程序代码（或者是字节码）。

初始化阶段是执行类构造器 `<clinit>` ()方法的过程。

-   `<clinit>` ()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的。

-   静态语句块只能访问到定义在静态语句块之前的变量。定义在静态语句块之后的变量，在前面的静态语句块中可以定义。

    ![](../../imgs/jvm/jvm-18.png)

-	虚拟机会保证在子类的 `<clinit>` ()方法执行之前，父类的 `<clinit>` ()方法已经执行完毕。这就意味着父类的静态语句块要优先于子类的静态语句块。

-	 `<clinit>` ()方法对于类或者接口来说并不是必需的。因为如果类中既没有静态语句块，也没有静态变量赋值的赋值动作，那么编译器可以不为这个类生成 `<clinit>` ()方法。

-	接口中不能使用静态语句块。接口与类都能生成 `<clinit>` ()方法，但是不一样，区别在于，接口在执行 `<clinit>` ()方法时，不会先去执行父接口的 `<clinit>` ()方法。只有等到需要的时候才会去执行父接口的 `<clinit>` ()方法。

-	 `<clinit>` ()方法在多线程的环境中能被JVM正确的加锁、同步。

# <a id="CLASSLOADER-MECHINE">类加载器</a>

### 概念

加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码块就是“类加载器”。

###	类与类加载器
比较两个类是否相等，还需要判断这两个类是否由同一个ClassLoader加载进来的。

###	双亲委派模型
1.	从Java虚拟机角度来看，只存在2中类加载器：
    -	启动类加载器（Bootstrap ClassLoader），在HotSpot中这个加载器是C++实现的。
    -  	其他类加载器，由Java语言实现的，独立于JVM外部，并且全都继承自抽象类java.lang.ClassLoader.

2.	从开发人员角度来看，存在3种类加载器：
    -	Bootstrap ClassLoader（启动类加载器）
    -	Extension ClassLoader（扩展类加载器）
    -	Application ClassLoader（应用程序类加载器）

###	双亲委派模式的工作过程

![](../../imgs/jvm/jvm-19.png)
 
如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此。因此所有的加载请求最终都应该委派到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己加载。
 
###	双亲委派模型的代码实现

实现双亲委派的代码都集中在java.lang.ClassLoader的loadClass()方法中。

![](../../imgs/jvm/jvm-20.png)
 
双亲委派模型的好处：
1.	每个类都只会被加载一次，避免了重复加载，这样也不会出现
2.	有效的避免了某些恶意类的加载（比如自定义的java.lang.Object类）。

### 双亲委派模式在什么情况下会被打破？

ContextClassLoader：有些时候ClassLoader的双亲委托机制不能完成一些特定的类加载任务，比如java提供一些SPI，由厂商来进行具体的实现，比如jdbc，各个数据库厂商根据java提供的SPI来实现各自数据库的连接；这些SPI都定义在核心类里，由bootstrap ClassLoader加载，而在SPI 接口中的代码经常需要加载具体的实现类，但厂商的具体实现又不能由Bootstrap ClassLoader加载，这个时候就需要ContextClassLoader。

##  [BACK](../../mds/summary.md)