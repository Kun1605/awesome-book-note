# ThreadLocal

### 目录
-   **1. 源码解析**
    -   [1.1 get()](#user-content-code-1-1)

ThreadLocal，即线程变量，是一个以ThreadLocal对象为键，任意对象为值的存储结构。这个结构被附带在线程上，也就是说一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值。

下面来介绍一下 ThreadLocal 中几个重要的方法，了解了这些方法基本就知道 ThreadLocal 是如何运作的了。

![](/imgs/concurrency/c-6-1.png)

## <a id="code-1-1">1.1 get()</a>

get() 是用来获取保存在当前线程中的副本变量。

```java
public T get() {
    // 获取当前线程
    Thread t = Thread.currentThread();

    // 根据获取当前线程的ThreadLocalMap
    ThreadLocalMap map = getMap(t);

    if (map != null) {
        // 查找以ThreadLocal对象为键值的Entry
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null)
            // 找到的话，就返回value
            return (T)e.value;
    }
    // map未初始化，初始化map，并将初始值返回
    return setInitialValue();
}
```

get() 内部调用了 getMap(Thread)、ThreadLocalMap.getEntry(ThreadLocal) 和 setInitialValue() 这三个方法，下面来逐个看看其细节实现。

### getMap(Thread)

```java
ThreadLocalMap getMap(Thread t) {
    return t.threadLocals;
}
```

顺着 t.threadLocals 找，你会发现原来这个 **threadLocals** 就是 **ThreadLocal.ThreadLocalMap** 的一个对象。

```java
ThreadLocal.ThreadLocalMap threadLocals = null;
```

继续看，这个 ThreadLocalMap 里面存着什么？ 这就需要看看下面调用的方法 getEntry(ThreadLocal)。

### getEntry(ThreadLocal)

```java
private Entry getEntry(ThreadLocal key) {
    int i = key.threadLocalHashCode & (table.length - 1);
    Entry e = table[i];
    if (e != null && e.get() == key)
        return e;
    else
        return getEntryAfterMiss(key, i, e);
}
```

这么一看是不是就很明了了，其实ThreadLocalMap管理着一组数组。

##  [BACK](/summary.md)