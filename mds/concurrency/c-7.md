# Condition

> 版本 JDK7

### 目录
-   [1. 对 Condition 大概的了解](#user-content-condition-1)
    -   [1.1 Condition 是什么？](#user-content-condition-1-1)
    -   [1.2 Condition 与 Object Monitor Methods 的区别？](#user-content-condition-1-2)
-   [2. 源码解析](#user-content-condition-2)
    -   [2.1 ConditionObject 的结构](#user-content-condition-2-1)
        -   [2.1.1 ConditionObject 的成员变量](#user-content-condition-2-1-1)
        -   [2.1.2 等待队列的基本结构](#user-content-condition-2-1-2)
    -   **2.2 ConditionObject 重写的方法解析**
        -   [2.2.1 await()](#user-content-condition-2-2-1)
        -   [2.2.2 awaitNanos(long)](#user-content-condition-2-2-2)
    -   **2.3 ConditionObject 的私有方法和 AQS 的一些方法解析**
        -   [2.3.1 addConditionWaiter (ConditionObject 私有)](#user-content-condition2-3-1)
        -   [2.3.2 isOnSyncQueue (AQS 的方法)](#user-content-condition-2-3-2)
        -   [2.3.3 checkInterruptWhileWaiting (CondtionObject 私有)](#user-content-condition-2-3-3)
        -   [2.3.4 unlinkCancelledWaiters (CondtionObject 私有)](#user-content-condition-2-3-4)
        -   [2.3.5 reportInterruptAfterWait (CondtionObject 私有)](#user-content-condition-2-3-5)
        -   [2.3.6 transferAfterCancelledWait (AQS 的方法)](#user-content-condition-2-3-6)


## <a id="condition-1">1. 对 Condition 大概的了解</a>

本篇讲到的 Condition 是指 `java.util.concurrent.locks.Condition`。

来看一下它的构造：

![](/imgs/concurrency/c-7-1.png)

原来它只是一个接口，仔细观察其内部结构，有没有一种似曾相识的感觉？对，它和 Object 中提供的一下方法有点相像，实际上他们的功能在一定程度上还是一样的。

![](/imgs/concurrency/c-7-2.png)

### <a id="condition-1-1">1.1 Condition 是什么？</a>

所以 Condition 到底是什么样的存在呢？

> Condition factors out the Object monitor methods (wait, notify and notifyAll) into distinct objects to give the effect of having multiple wait-sets per object, by combining them with the use of arbitrary Lock implementations. Where a Lock replaces the use of synchronized methods and statements, a Condition replaces the use of the Object monitor methods.

根据上面官方对 Condition 的描述，我的理解就是：**Condition** 是将 **Object monitor methods**（比如：wait, notify, notifyAll）分解到每个不同的对象中，通过将这些新方法与任意实现了 Lock（java.util.concurrent.locks.Lock） 接口的锁（比如：ReentrantLock，ReentrantReadWriteLock等）结合使用，来实现每个对象都有多个 wait-sets（等待队列）的效果。如果 Lock 代替了 synchronized 方法和语句的使用，那么 Condition 将代替 Object monitor methods。

简单点理解就是，Condition 细化并且丰富了原来的 Object monitor methods。

### <a id="condition-1-2">1.2 Condition 与 Object Monitor Methods 的区别？</a>

既然 Condition 是 Object Monitor Methods 的替代品，那么它们之间有什么区别呢？

1.  Condition 提供了不响应中断的等待方法 - `void awaitUninterruptibly();`，而这个在 Object 中是没有的。

2.  Condition 是配合 Lock 使用，而 Object Monitor Methods 是配合 synchronized 使用的。

> 引用《Java 并发编程的艺术》

### Condition 与 Object Monitor Methods 的异同：

| 对比项 | Object Monitor Methods | Condition |
| :-: | :-: | :-: |
| 前置条件 | 获取对象的锁 - **synchronized** | 调用 Lock.lock() 获取锁<br> 调用 Lock.newCondition() 获取 Condition 对象 |
| 调用方式 | 直接调用<br> 如：object.wait() | 直接调用<br> 如：condition.wait() |
| 等待队列个数 | 一个 | 多个 |
| 当前线程释放锁并进入等待状态 | 支持 | 支持 |
| 当前线程释放锁并进入等待状态，在等待状态中 **不响应** 中断 | 不支持 | 调用 condition.awaitUninterruptibly() |
| 当前线程释放锁并进入 **超时等待状态** | 支持 | 支持 |
| 当前线程释放锁并进入 **等待状态** 到将来的某个时间 | 不支持 | 调用 condition.awaitUntil(Date deadline) |
| 唤醒等待队列中的一个线程 | 支持 | 支持 |
| 唤醒等待队列中的全部线程 | 支持 | 支持 |

## <a id="condition-2">2. 源码解析</a>

下面的目前实现了 Condition 接口的所有实现类：

![](/imgs/concurrency/c-7-3.png)

下面我将以 `java.util.concurrent.locks.AbstractQueuedSynchronizer` 的内部静态类 - **ConditionObject** 为例，来解析其实现 **Condition** 接口的细节。

### <a id="condition-2-1">2.1 ConditionObject 的结构</a>

![](/imgs/concurrency/c-7-4.png)

ConditionObject 中有 2 个重要的成员变量：firstWaiter 和 lastWaiter。这两个成员变量和同步器（[**AQS**](/mds/concurrency/c-5.md)）中的节点都是同一类型 —— `AbstractQueuedSynchronizer.Node`。

ConditionObject 中维护着等待队列。等待队列与同步队列一样都是遵循 **FIFO** 规则。

#### <a id="condition-2-1-1">2.1.1 ConditionObject 的成员变量</a>

```java
/** 等待队列的头结点 */
private transient Node firstWaiter;
/** 等待队列的尾节点 */
private transient Node lastWaiter;
/** 中断模式之一：REINTERRUPT */
private static final int REINTERRUPT =  1;
/** 中断模式之一：THROW_IE */
private static final int THROW_IE    = -1;
```

解释下 interruptMode，interruptMode 可以取值为 **REINTERRUPT**（1）、**THROW_IE**（-1）、0。

-   REINTERRUPT： 代表 await 返回的时候，需要重新设置中断状态
-   THROW_IE： 代表 await 返回的时候，需要抛出 InterruptedException 异常
-   0 ：说明在 await 期间，没有发生中断

#### <a id="condition-2-1-2">2.1.2 等待队列的基本结构</a>

一个 Condition 包含一个等待队列，Condition 与同步器（AQS）一样都有首节点（firstWaiter）和尾节点（lastWaiter）。

![](/imgs/concurrency/c-7-5.png)

与同步器不同的地方是：等待队列中的每个节点只存有下一个等待节点（即nextWaiter），而没有保存前驱节点的地址。

![](/imgs/concurrency/c-7-6.png)

如上如所示，Condition 的实现是同步器的内部类，因此每个 Condition 实例都能访问同步器提供的方法，相当于每个 Condition 都拥有所属同步器的引用。

#### <a id="condition-2-2-1">2.2.1 await()</a>

await() 这个方法是响应中断。

作用：使调用该方法的线程会进入等待队列，然后释放对象锁。

```java
public final void await() throws InterruptedException {
    if (Thread.interrupted())
        // 当前线程被标记为中断状态，需要抛出中断异常
        throw new InterruptedException();
    // 将当前线程“加工”成节点加入到等待队列中，具体实现后面会介绍
    Node node = addConditionWaiter();
    // 释放对象锁
    int savedState = fullyRelease(node);
    int interruptMode = 0;
    while (!isOnSyncQueue(node)) {// 当前线程节点所在的队列不是同步队列
        // 阻塞当前线程
        LockSupport.park(this);

        // 当前线程退出阻塞状态，先判断一下当前线程是否因为中断而退出的
        // 如果是中断而退出的，退出 while 循环
        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
            break;
    }

    /** 
     * 代码执行到这里有两种情况：
     * 1. 当前节点已经在同步队列中
     * 2. 当前节点在等待队列中被标记为中断状态
     */

    // 下面开始获取对象锁
    if (acquireQueued(node, savedState) && interruptMode != THROW_IE)
        /**
         * 获取对象锁失败，并且此时线程已经被打断了
         * 注意：acquireQueued 返回的是当前线程是否是因为中断而退出的
         * 如果 acquireQueued 返回 false，说明线程成功获取对象锁
         * 如果 acquireQueued 返回 true，说明线程因为被中断而获取对象锁失败
         */
        interruptMode = REINTERRUPT;
    
    // 如果当前节点还未从等待队列中清除出去，那么进行清除
    if (node.nextWaiter != null) // clean up if cancelled
        unlinkCancelledWaiters();
    
    if (interruptMode != 0)
        // 线程被中断，需要根据 interruptMode 来判断是否是抛出中断异常，还是重新将当前线程标记被中断状态
        reportInterruptAfterWait(interruptMode);
}
```

小结一下，await() 这个方法只有两种情况下才能够返回方法：

1.  当前线程被唤醒
1.  当前线程被中断

#### <a id="condition-2-2-2">2.2.2 awaitNanos(long)</a>

也是能够响应中断的。awaitNanos 与 await 整体上功能是差不多的。但是，awaitNanos 比 await 多了一个等待时间超时功能，超过指定的时间后也会退出方法。

```java
public final long awaitNanos(long nanosTimeout) throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    Node node = addConditionWaiter();
    int savedState = fullyRelease(node);
    // 获取当前JVM系统的时间
    long lastTime = System.nanoTime();
    int interruptMode = 0;
    while (!isOnSyncQueue(node)) {// 当前节点在等待队列
        if (nanosTimeout <= 0L) {
            transferAfterCancelledWait(node);
            break;
        }
        LockSupport.parkNanos(this, nanosTimeout);
        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
            break;

        long now = System.nanoTime();
        nanosTimeout -= now - lastTime;
        lastTime = now;
    }
    if (acquireQueued(node, savedState) && interruptMode != THROW_IE)
        interruptMode = REINTERRUPT;
    if (node.nextWaiter != null)
        unlinkCancelledWaiters();
    if (interruptMode != 0)
        reportInterruptAfterWait(interruptMode);
    return nanosTimeout - (System.nanoTime() - lastTime);
    }
```

### <a id="condition-2-3">2.3 ConditionObject 的私有方法和 AQS 的一些方法解析</a>

> 看了上面重写的方法可能还有一些疑惑的地方，可以看看其内部的调用方法实现，所剩的疑惑应该就能消除了。

#### <a id="condition-2-3-1">2.3.1 addConditionWaiter (ConditionObject 私有)</a>

addConditionWaiter，将当前线程构造成一个等待队列中的节点。

```java
private Node addConditionWaiter() {
    // 获取等待队列中的尾节点
    Node t = lastWaiter;

    // If lastWaiter is cancelled, clean out.
    if (t != null && t.waitStatus != Node.CONDITION) {

        /**
         * 这个方法会遍历整个等待队列 并且 将所有已经取消的节点清除出去
         * 当然这个时候的 lastWaiter 肯定已经发生的改变。
         */
        unlinkCancelledWaiters();
        t = lastWaiter;
    }

    // 构造节点 并且 将节点放到等待队列的末尾
    Node node = new Node(Thread.currentThread(), Node.CONDITION);
    if (t == null)
        firstWaiter = node;
    else
        t.nextWaiter = node;
    lastWaiter = node;
    return node;
}
```

#### <a id="condition-2-3-2">2.3.2 isOnSyncQueue (AQS的方法)</a>

isOnSyncQueue 用来检查当前线程是否在 **同步队列** 中。

```java
final boolean isOnSyncQueue(Node node) {

    // 如果当前节点的状态为 CODITION 或者 当前节点的前驱节点为null，都能说明当前节点不在同步队列中
    if (node.waitStatus == Node.CONDITION || node.prev == null)
        return false;

    // 如果当前节点存在后继节点，说明已经在同步队列中
    if (node.next != null) // If has successor, it must be on queue
        return true;
    
    /**
     * 执行到这里说明此时的节点状态:
     * (node.waitStatus != Node.CONDITION || node.prev != null) && node.next == null
     * 这个时候，还差尾节点没有判断，所以调用 findNodeTail 来检测
     */
    return findNodeFromTail(node);
}
```

```java
/**
 * 从尾节点开始遍历同步队列来检查当前节点是否存在于同步队列中。
 * 存在，返回 true；否则，返回false。
 */
private boolean findNodeFromTail(Node node) {
    Node t = tail;
    for (;;) {
        if (t == node)
            return true;
        if (t == null)
            return false;
        t = t.prev;
    }
}
```

#### <a id="condition-2-3-3">2.3.3 checkInterruptWhileWaiting (CondtionObject 私有)</a>

这个方法是用来检查当前线程是否被 **标记为中断状态**，线程被中断返回 1 或 -1；线程如果没有被中断，返回 0 。

```java
private int checkInterruptWhileWaiting(Node node) {
    return Thread.interrupted() ?
        (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :
        0;
}
```

#### <a id="condition-2-3-4">2.3.4 unlinkCancelledWaiters (CondtionObject 私有)</a>

unlinkCancelledWaiters，遍历整个等待队列，将等待队列中被取消的节点清理出队列。

```java
private void unlinkCancelledWaiters() {
    Node t = firstWaiter;
    Node trail = null;

    // 遍历整个等待队列
    while (t != null) {
        Node next = t.nextWaiter;

        if (t.waitStatus != Node.CONDITION) {
            /** t节点需要被清除出等待队列 **/
            
            t.nextWaiter = null;
            // 更新 firstWaiter 或 lasterWaiter 所指向的节点
            if (trail == null)
                firstWaiter = next;
            else
                trail.nextWaiter = next;
            if (next == null)
                lastWaiter = trail;
        }
        else // t节点仍然在等待队列中
            trail = t;

        // 检查下一个节点
        t = next;
    }
}
```

#### <a id="condition-2-3-5">2.3.5 reportInterruptAfterWait (CondtionObject 私有)</a>

reportInterruptAfterWait(int)，根据 interruptedMode 的值，来决定当前线程到底是直接抛出异常还是将当前线程标记为中断状态。

```java
private void reportInterruptAfterWait(int interruptMode) throws InterruptedException {
    // -1，抛出中断异常
    if (interruptMode == THROW_IE)
        throw new InterruptedException();
    // 1，将当前线程标记为中断状态
    else if (interruptMode == REINTERRUPT)
        selfInterrupt();
}
```

#### <a id="condition-2-3-6">2.3.6 transferAfterCancelledWait (AQS 的方法)</a>

```java
/**
 * 当前等待节点从等待队列中移除时，如果有必要，将其传输到同步队列中
 */
final boolean transferAfterCancelledWait(Node node) {
    if (compareAndSetWaitStatus(node, Node.CONDITION, 0)) {
        // 成功改变当前节点的状态，将其放入同步队列中
        enq(node);
        return true;
    }
    while (!isOnSyncQueue(node))
        Thread.yield();
    return false;
}
```

-   返回 true，说明成功将节点从等待队列传输到同步队列中。
-   返回 false，说明当前节点已经在同步队列中。

## 参考

-   《Java 并发编程的艺术》
-   [一行一行源码分析清楚 AbstractQueuedSynchronizer (二)](https://javadoop.com/post/AbstractQueuedSynchronizer-2)