# ReadWriteLock

> 看本文之前，需要了解 [**AQS**](/mds/concurrency/c-5.md) 和 [**ReentrantLock**](/mds/concurrency/c-5-1.md)。下文如果不做特别说明，AQS 都是指 AbstractQueuedSynchronizer。

### 目录
-   [1. 特性](#user-content-rwl-1)
-   [2. 解读 ReentrantReadWriteLock](#user-content-rwl-2)
    -   [2.1 ReentrantReadWriteLock 的结构](#user-content-rwl-2-1)
        -   [2.1.1 构造方法](#user-content-rwl-2-1-1)
        -   [2.1.2 ReadLock 与 WriteLock](#user-content-rwl-2-1-2)
        -   [2.1.3 小结](#user-content-rwl-2-1-3)
    -   2.2 **源码解读**
        -   [2.2.1 Sync - 读、写的同步状态获取方式](#user-content-rwl-2-2-1)
        -   [2.2.2 Sync - 独占式获取与释放的具体实现](#user-content-rwl-2-2-2)

## <a id="rwl-1">1. 特性</a>

ReadWriteLock 翻译过来就是读写锁。读写锁在 **同一时刻** 允许多个线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。

使用场景：读多写少的环境

| ReentrantReadWriteLock 的特性 | 说明 |
| :-: | :-: |
| 公平性的选择 | 支持非公平(默认)和公平的锁获取方式，就吞吐量而言，非公平要优于公平 |
| 重进入 | 该锁支持重进入。以读写线程为例：读线程在获取了读锁之后，(获取读锁的线程)该线程能够再次获取读锁；而写线程在获取写锁之后，能够再次获取写锁，同时也能获取读锁。|
| 锁降级 | 遵循下面的次序：1.获取写锁 2. 获取读锁 3.释放写锁。写锁就能降级成为读锁，反之不行。|

## <a id="rwl-2">2. 解读 ReentrantReadWriteLock</a>

ReentrantReadWriteLock 是Java并发包里面提供的唯一的一个读写锁实现。

![](/imgs/concurrency/c-5$2-2.png)

ReadWriteLock 提供了2个抽象方法 readLock() 和 writeLock() 用于获取读锁和写锁。

下面就让我们来看看这个复杂的锁。

### <a id="rwl-2-1">2.1 ReentrantReadWriteLock 的结构</a>

![](/imgs/concurrency/c-5$2-3.png)

从上面的截图中可以看出，ReentrantReadWriteLock 中有很多的内部静态类。下面我们从这几个内部类来熟悉一下其内部结构。

#### <a id="rwl-2-1-1">2.1.1 构造方法</a>

ReentrantReadWriteLock 提供了2个构造方法：

```java
public ReentrantReadWriteLock() {
    this(false);
}

public ReentrantReadWriteLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
    readerLock = new ReadLock(this);
    writerLock = new WriteLock(this);
}
```

从上面的代码可以看出，这2个构造方法决定了 ReentrantReadWriteLock 的获取是否是公平性的，同时初始化了 ReadLock 和 WriteLock。

![](/imgs/concurrency/c-5$2-4.png)

有趣的是，FairSync 与 NonfairSync 之间的唯一不同之处就是各自实现了父类 Sync 的 readerShouldBlock 和 writerShouldBlock 这两个抽象方法(暂时不必关心，后面后面会介绍)。

#### <a id="rwl-2-1-2">2.1.2 ReadLock 与 WriteLock</a>

下面来看看 ReadLock 和 WriteLock 这两个类的结构。

![](/imgs/concurrency/c-5$2-5.png)

> 注意：ReadLock 与 WriteLock 采用的是两种完全不同的 lock 方式。

| 锁 | 类型 |
| :-: | :-: |
| ReadLock | 共享模式 - acquireShared(1) |
| WriteLock | 独占模式 - acquire(1) |

#### <a id="rwl-2-1-3">2.1.3 小结</a>

1. Sync 是 AbstractQueuedSynchronizer 的子类，然后再衍生出了公平模式和非公平模式。

1. Sync 重写了 AbstractQueuedSynchronizer 的 tryRelease、tryAcquire、tryReleaseShared、tryAcquireShared 和 isHeldExclusively 这5个方法。Sync 既能提供独占式获取与释放锁的功能，也拥有共享式获取与释放锁的功能。

1. ReadLock 和 WriteLock 的内部方法几乎都是由 Sync 来实现的。但是 ReadLock 和 WriteLock 分别继承 Sync 的不同获取锁的方式：ReadLock - 共享式；WriteLock - 独占式。

1. ReadLock 和 WriteLock 一样，都是有公平模式和非公平模式。

![](/imgs/concurrency/c-5$2-6.svg)

#### <a id="rwl-2-2-1">2.2.1 Sync - 读、写的同步状态获取方式</a>

前面我们介绍过 Sync 的结构，知道 Sync 是同时拥有独占锁和共享锁的。但是 Sync 是如何快速确定读和写的各自的状态呢？答案就是通过位运算。

```java
abstract static class Sync extends AbstractQueuedSynchronizer {
    
    ... ...

    static final int SHARED_SHIFT   = 16;
    static final int SHARED_UNIT    = (1 << SHARED_SHIFT);
    // MAX_COUNT == 2^16 - 1，即读写锁各自最大的同步状态数
    static final int MAX_COUNT      = (1 << SHARED_SHIFT) - 1;
    // 转换成二进制 == 00000000 00000000 11111111 11111111
    static final int EXCLUSIVE_MASK = (1 << SHARED_SHIFT) - 1;

    // 读的同步状态为高16位
    static int sharedCount(int c)    { return c >>> SHARED_SHIFT; }
    // 写的同步状态的第16位
    static int exclusiveCount(int c) { return c & EXCLUSIVE_MASK; }

    ... ...
}
```

假设当前同步状态为S，

- 读的同步状态为：S >>> 0x0000FFFF
- 写的同步状态为：S & 0x0000FFFF

![](/imgs/concurrency/c-5$2-1.png)

#### <a id="rwl-2-2-2">2.2.2 Sync - 独占式获取与释放的具体实现</a>

-   独占锁的获取
    ```java
     protected final boolean tryAcquire(int acquires) {
        
        // 获取当前线程
        Thread current = Thread.currentThread();
        // 获取当前的同步状态
        int c = getState();
        // 计算当前写锁的同步状态
        int w = exclusiveCount(c);
        if (c != 0) {
            /**
             * 1. c != 0 && w == 0：说明这个时候拥有读锁，获取写锁失败。此时是不能够获取写锁的，这也证实 ReentrantReadWriteLock 是不支持锁升级的。
             * 2. c != 0 && w != 0 && current != getExclusiveOwnerThread()：说明读锁被其他线程占用着。
             */
            if (w == 0 || current != getExclusiveOwnerThread())
                return false;
            
            // 如果超过 MAX_COUNT 抛出异常
            if (w + exclusiveCount(acquires) > MAX_COUNT)
                throw new Error("Maximum lock count exceeded");
            
            // 锁重入
            setState(c + acquires);
            return true;
        }

        /**
         * 1. 如果是公平模式下，writerShouldBlock 调用的是 AQS 的 hasQueuedPredecessors() 来判断是否可以进行 CAS (后面会介绍)。
         * 2. 如果是非公平模式下，writerShouldBlock 返回 false，然后进行 CAS 尝试将写的状态更新，如果成功返回true，失败返回false。
         */
        if (writerShouldBlock() ||
            !compareAndSetState(c, c + acquires))
            return false;

        // 将当前线程标识为拥有写锁的线程
        setExclusiveOwnerThread(current);
        return true;
    }
    ```

    从上面独占锁的获取我们可以归纳出读写锁不能别获取的几种情况：

    -   getState() != 0：
        1.  当前线程拥有读锁。

        1.  当前写锁被正被其他线程占用中。

    -   getState() == 0 且 此时的读写锁是公平模式 且 同步队列中已经有线程在等待获取锁，此时也不能获取写锁。

## 参考

-   《Java并发编程的艺术 - 第五章》

##  [BACK](/summary.md)