# ReadWriteLock

> 版本JDK7

看本文之前，需要了解 [**AQS**](/mds/concurrency/c-5.md) 和 [**ReentrantLock**](/mds/concurrency/c-5-1.md)。下文如果不做特别说明，AQS 都是指 AbstractQueuedSynchronizer。

### 目录
-   [1. 特性](#user-content-rwl-1)
-   [2. 解读 ReentrantReadWriteLock](#user-content-rwl-2)
    -   [2.1 ReentrantReadWriteLock 的结构](#user-content-rwl-2-1)
        -   [2.1.1 构造方法](#user-content-rwl-2-1-1)
        -   [2.1.2 ReadLock 与 WriteLock](#user-content-rwl-2-1-2)
        -   [2.1.3 小结](#user-content-rwl-2-1-3)
    -   2.2 **源码解读**
        -   [2.2.1 Sync - 读、写的同步状态获取方式](#user-content-rwl-2-2-1)
        -   [2.2.2 Sync - 独占式获取与释放锁的具体实现](#user-content-rwl-2-2-2)
            -   [hasQueuedPredecessors() 解析](#user-content-hasQueuedPredecessors)
        -   [2.2.3 Sync - 共享式获取与释放锁的具体实现](#user-content-rwl-2-2-3)

## <a id="rwl-1">1. 特性</a>

ReadWriteLock 翻译过来就是读写锁。读写锁在 **同一时刻** 允许多个线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。

使用场景：读多写少的环境

ReentrantReadWriteLock 是 ReadWriteLock 的唯一实现。

| ReentrantReadWriteLock 的特性 | 说明 |
| :-: | :-: |
| 公平性的选择 | 支持非公平(默认)和公平的锁获取方式，就吞吐量而言，非公平要优于公平 |
| 重进入 | 该锁支持重进入。以读写线程为例：读线程在获取了读锁之后，(获取读锁的线程)该线程能够再次获取读锁；而写线程在获取写锁之后，能够再次获取写锁，同时也能获取读锁。|
| 锁降级 | 遵循下面的次序：1.获取写锁 2. 获取读锁 3.释放写锁。写锁就能降级成为读锁，反之不行。|

## <a id="rwl-2">2. 解读 ReentrantReadWriteLock</a>

ReentrantReadWriteLock 是Java并发包里面提供的唯一的一个读写锁实现。

![](/imgs/concurrency/c-5$2-2.png)

ReadWriteLock 提供了2个抽象方法 readLock() 和 writeLock() 用于获取读锁和写锁。

下面就让我们来看看这个复杂的锁。

### <a id="rwl-2-1">2.1 ReentrantReadWriteLock 的结构</a>

![](/imgs/concurrency/c-5$2-3.png)

从上面的截图中可以看出，ReentrantReadWriteLock 中有很多的内部静态类。下面我们从这几个内部类来熟悉一下其内部结构。

#### <a id="rwl-2-1-1">2.1.1 构造方法</a>

ReentrantReadWriteLock 提供了2个构造方法：

```java
public ReentrantReadWriteLock() {
    this(false);
}

public ReentrantReadWriteLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
    readerLock = new ReadLock(this);
    writerLock = new WriteLock(this);
}
```

从上面的代码可以看出，这2个构造方法决定了 ReentrantReadWriteLock 的获取是否是公平性的，同时初始化了 ReadLock 和 WriteLock。

![](/imgs/concurrency/c-5$2-4.png)

有趣的是，FairSync 与 NonfairSync 之间的唯一不同之处就是各自实现了父类 Sync 的 readerShouldBlock 和 writerShouldBlock 这两个抽象方法(暂时不必关心，后面后面会介绍)。

#### <a id="rwl-2-1-2">2.1.2 ReadLock 与 WriteLock</a>

下面来看看 ReadLock 和 WriteLock 这两个类的结构。

![](/imgs/concurrency/c-5$2-5.png)

> 注意：ReadLock 与 WriteLock 采用的是两种完全不同的 lock 方式。

| 锁 | 类型 |
| :-: | :-: |
| ReadLock | 共享模式 - acquireShared(1) |
| WriteLock | 独占模式 - acquire(1) |

#### <a id="rwl-2-1-3">2.1.3 小结</a>

1. Sync 是 AbstractQueuedSynchronizer 的子类，然后再衍生出了公平模式和非公平模式。

1. Sync 重写了 AbstractQueuedSynchronizer 的 tryRelease、tryAcquire、tryReleaseShared、tryAcquireShared 和 isHeldExclusively 这5个方法。Sync 既能提供独占式获取与释放锁的功能，也拥有共享式获取与释放锁的功能。

1. ReadLock 和 WriteLock 的内部方法几乎都是由 Sync 来实现的。但是 ReadLock 和 WriteLock 分别继承 Sync 的不同获取锁的方式：ReadLock - 共享式；WriteLock - 独占式。

1. ReadLock 和 WriteLock 一样，都是有公平模式和非公平模式。

![](/imgs/concurrency/c-5$2-6.svg)

#### <a id="rwl-2-2-1">2.2.1 Sync - 读、写的同步状态获取方式</a>

前面我们介绍过 Sync 的结构，知道 Sync 是同时拥有独占锁和共享锁的。但是 Sync 是如何快速确定读和写的各自的状态呢？答案就是通过位运算。

```java
abstract static class Sync extends AbstractQueuedSynchronizer {
    
    ... ...

    static final int SHARED_SHIFT   = 16;
    static final int SHARED_UNIT    = (1 << SHARED_SHIFT);
    // MAX_COUNT == 2^16 - 1，即读写锁各自最大的同步状态数
    static final int MAX_COUNT      = (1 << SHARED_SHIFT) - 1;
    // 转换成二进制 == 00000000 00000000 11111111 11111111
    static final int EXCLUSIVE_MASK = (1 << SHARED_SHIFT) - 1;

    // 读的同步状态为高16位
    static int sharedCount(int c)    { return c >>> SHARED_SHIFT; }
    // 写的同步状态的第16位
    static int exclusiveCount(int c) { return c & EXCLUSIVE_MASK; }

    ... ...
}
```

假设当前同步状态为S，

- 读的同步状态为：S >>> 0x0000FFFF
- 写的同步状态为：S & 0x0000FFFF

![](/imgs/concurrency/c-5$2-1.png)

#### <a id="rwl-2-2-2">2.2.2 Sync - 独占式获取与释放的具体实现</a>

> 下面可能会出现独占锁和写锁这两个词，如果不做特殊书名，这两个就是一个意思。

-   独占锁的获取
    ```java
     protected final boolean tryAcquire(int acquires) {
        
        // 获取当前线程
        Thread current = Thread.currentThread();
        // 获取当前的同步状态
        int c = getState();
        // 计算当前写锁的同步状态
        int w = exclusiveCount(c);
        if (c != 0) {
            /**
             * 1. c != 0 && w == 0：说明这个时候拥有读锁，获取写锁失败。此时是不能够获取写锁的，这也证实 ReentrantReadWriteLock 是不支持锁升级的。
             * 2. c != 0 && w != 0 && current != getExclusiveOwnerThread()：说明读锁被其他线程占用着。
             */
            if (w == 0 || current != getExclusiveOwnerThread())
                return false;
            
            // 如果超过 MAX_COUNT 抛出异常
            if (w + exclusiveCount(acquires) > MAX_COUNT)
                throw new Error("Maximum lock count exceeded");
            
            // 锁重入
            setState(c + acquires);
            return true;
        }

        /**
         * 1. 如果是公平模式下，writerShouldBlock 调用的是 AQS 的 hasQueuedPredecessors() 来查询是否有任何线程等待获取锁的时间长于当前线程。
         * hasQueuedPredecessors()返回true，说明存在线程等待时间长于当前线程。
         * 2. 如果是非公平模式下，writerShouldBlock 返回 false，然后进行 CAS 尝试将写的状态更新，如果成功，该方法返回true；失败，返回false。
         */
        if (writerShouldBlock() ||
            !compareAndSetState(c, c + acquires))
            return false;

        // 将当前线程标识为拥有写锁的线程
        setExclusiveOwnerThread(current);
        return true;
    }
    ```

    从上面独占锁的获取我们可以归纳出读写锁不能别获取的几种情况：

    -   getState() != 0：
        1.  当前线程拥有读锁。

        1.  当前写锁被正被其他线程占用中。

    -   getState() == 0 且 此时的读写锁是公平模式 且 同步队列中已经有线程在等待获取锁，此时也不能获取写锁。

-   独占式的释放

    ```java
    protected final boolean tryRelease(int releases) {
        // 如果当前线程不是拥有写锁的线程，将抛出异常。
        if (!isHeldExclusively())
            throw new IllegalMonitorStateException();

        // 计算释放之后的同步状态值
        int nextc = getState() - releases;
        // 新写锁的同步状态值如果为0，说明完全释放了。
        boolean free = exclusiveCount(nextc) == 0;
        if (free)
            setExclusiveOwnerThread(null);
        // 更新同步状态值
        setState(nextc);
        return free;
    }
    ```

    对于独占锁的释放，你可能会注意到，只有将重入的锁全部释放掉才算是真正的释放了当前线程对写锁的占有。

#### <a id="hasQueuedPredecessors">hasQueuedPredecessors() 解析</a>

前面解析写锁的获取过程的时候，我们可以看到，在公平模式下面，writerShouldBlock() 这个方法内部调用了 hasQueuedPredecessors()。下面，让我们来看看 hasQueuedPredecessors 是如何来判断当前同步队列中是否有线程等待时间长于当前线程。

```java
public final boolean hasQueuedPredecessors() {
    Node t = tail; // Read fields in reverse initialization order
    Node h = head;
    Node s;
    return h != t &&
        ((s = h.next) == null || s.thread != Thread.currentThread());
}
```

代码量很少，但是想要看明白却不太简单。

我归纳了一下 hasQueuedPredecessors 返回值所对应的几种情况：

-   返回 **true**，只有一种情况：当前同步队列中有等待的线程存在。

-   返回 **false**，有两种情况：
    1.  同步队列中没有等待的线程存在。
    1.  当前的线程为同步队列中的 **head**。

简单画了一个图来表示：

![](/imgs/concurrency/c-5$2-7.svg)

#### <a id="rwl-2-2-3">2.2.3 Sync - 共享式获取与释放锁的具体实现</a>

> 如果不做特殊说明，共享锁与读锁代表同一个意思。

-   共享式获取锁

    tryAcquireShared(int) > 0 说明成功获取
    
    ```java
    protected final int tryAcquireShared(int unused) {
        Thread current = Thread.currentThread();
        int c = getState();
        if (exclusiveCount(c) != 0 &&
            getExclusiveOwnerThread() != current)
            return -1;
        int r = sharedCount(c);
        if (!readerShouldBlock() &&
            r < MAX_COUNT &&
            compareAndSetState(c, c + SHARED_UNIT)) {
            if (r == 0) {
                firstReader = current;
                firstReaderHoldCount = 1;
            } else if (firstReader == current) {
                firstReaderHoldCount++;
            } else {
                HoldCounter rh = cachedHoldCounter;
                if (rh == null || rh.tid != current.getId())
                    cachedHoldCounter = rh = readHolds.get();
                else if (rh.count == 0)
                    readHolds.set(rh);
                rh.count++;
            }
            return 1;
        }
        return fullTryAcquireShared(current);
    }
    ```

## 参考

-   《Java并发编程的艺术 - 第五章》

##  [BACK](/summary.md)