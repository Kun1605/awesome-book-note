# ReadWriteLock

> 看本文之前，需要了解 [**AQS**](/mds/concurrency/c-5.md) 和 [**ReentrantLock**](/mds/concurrency/c-5-1.md)。

### 目录
-   [1. 特性](#user-content-rwl-1)
-   [2. 解读 ReentrantReadWriteLock](#user-content-rwl-2)
    -   [2.1 ReentrantReadWriteLock 的结构](#user-content-rwl-2-1)
        -   [2.1.1 构造方法](#user-content-rwl-2-1-1)
        -   [小结]

## <a id="rwl-1">1. 特性</a>

ReadWriteLock 翻译过来就是读写锁。读写锁在 **同一时刻** 允许多个线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。

使用场景：读多写少的环境

| ReentrantReadWriteLock 的特性 | 说明 |
| :-: | :-: |
| 公平性的选择 | 支持非公平(默认)和公平的锁获取方式，就吞吐量而言，非公平要优于公平 |
| 重进入 | 该锁支持重进入。以读写线程为例：读线程在获取了读锁之后，(获取读锁的线程)该线程能够再次获取读锁；而写线程在获取写锁之后，能够再次获取写锁，同时也能获取读锁。|
| 锁降级 | 遵循下面的次序：1.获取写锁 2. 获取读锁 3.释放写锁。写锁就能降级成为读锁，反之不行。|

## <a id="rwl-2">2. 解读 ReentrantReadWriteLock</a>

ReentrantReadWriteLock 是Java并发包里面提供的唯一的一个读写锁实现。

![](/imgs/concurrency/c-5$2-2.png)

ReadWriteLock 提供了2个抽象方法 readLock() 和 writeLock() 用于获取读锁和写锁。

下面就让我们来看看这个复杂的锁。

### <a id="rwl-2-1">2.1 ReentrantReadWriteLock 的结构</a>

![](/imgs/concurrency/c-5$2-3.png)

从上面的截图中可以看出，ReentrantReadWriteLock 中有很多的内部静态类。下面我们从这几个内部类来熟悉一下其内部结构。

#### <a id="rwl-2-1-1">2.1.1 构造方法</a>

ReentrantReadWriteLock 提供了2个构造方法：

```java
public ReentrantReadWriteLock() {
    this(false);
}

public ReentrantReadWriteLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
    readerLock = new ReadLock(this);
    writerLock = new WriteLock(this);
}
```

从上面的代码可以看出，这2个构造方法决定了 ReentrantReadWriteLock 的公平性。

## 参考

-   《Java并发编程的艺术 - 第五章》

##  [BACK](/summary.md)