# fork/join 框架

> Fork/Join 是 JDK7 提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小人物，最终汇总每个小任务结果后的带大任务结果的框架。 -- 引自《Java 并发编程的艺术》

## 目录

-   [1. Fork-Join 模型介绍](#user-content-fj-1)
-   [2. 并发与并行的区别](#user-content-fj-2)
-   [3. fork/join 框架如何工作？](#user-content-fj-3)

## <a id="fj-1">1. Fork-Join 模型介绍</a>

![](/imgs/concurrency/c-8-1.png)

上图是 Fork-Join 模型的示例图，其中程序的三个区域允许并行执行各种颜色的块。顺序执行显示在顶部，它等效的 Fork-Join 执行显示在底部。比如，Master thread 执行到 Parallel Task I 时，此时可以并行执行 A, B 和 C 这三个 task，全部执行完了之后再将三个执行结果合并到 Master Thread。

## <a id="fj-2">2. 并发与并行的区别</a>

在介绍 fork/join 框架之前，我们先来了解一下并行和并发之间的区别。

-   并发，是在重叠的时间周期中执行两个或多个任务，但不一定同时执行。

    ![](/imgs/concurrency/c-8-2.gif)

    <center><strong>Concurrent: 2 queues, 1 vending machine</strong></center>

-   并行，是两个或多个任务同时执行。

    ![](/imgs/concurrency/c-8-3.gif)

    <center><strong>Concurrent: 2 queues, 2 vending machine</strong></center>

## <a id="fj-3">3. fork/join 框架如何工作？</a>

fork/join 框架旨在 **加速** 任务的执行，这些任务可以被划分为其他更小的子任务，并行执行它们，然后将它们的结果组合起来得到一个单独的子任务。

由于这个原因，子任务必须相互独立，操作必须是无状态的，因此这个框架不是所有问题的最佳解决方案。

fork/join 应用了 **分治原则**，通过递归的方式将任务划分为更小的子任务，直到达到给定的阈值(这是 fork 部分)。

然后，子任务被独立处理，如果它们返回一个结果，所有的结果将被递归地组合成一个结果(这是 join 部分)。

![](/imgs/concurrency/c-8-4.gif)

为了并行的执行这些子任务，fork/join 框架使用一个线程池，线程池中的线程数量等于与Java虚拟机(JVM)默认情况下可用的处理器数量相等(这里指的是 ForkJoinPool 的默认构造方法)。

每个线程都有它自己的双端队列(deque)，它们用自己的队列储存要被执行的子任务们。

deque 是一种队列，它支持从前(头)或后(尾)添加或删除元素。

deque 有两个特点：

1.  一个线程一次只能执行一个任务(被执行的任务位于队列的头结点)

1.  deque 实现了工作窃取(working-stealing)算法，来平衡线程的工作负荷。

工作窃取算法是指某个线程从其他队列里窃取任务来执行。为什么会发生这种情况？假设这里有 2 个线程 A 和 B，线程 A 先完成了队列里面的任务，而此时 线程 B 还正在处理任务中，出于增加吞吐量的目的，线程 A 会窃取 线程 B 中的队列里的任务。

通常情况下，为了减少窃取任务线程和被窃取任务线程之间的竞争，被窃取任务线程永远从双端队列的 **头部** 获取任务执行，而窃取任务的线程永远从双端队列的 **尾部** 窃取任务执行。

## 参考

-   [Fork-Join Model](https://en.wikipedia.org/wiki/Fork-join_model)
-   [Introduction to the Fork/Join Framework](https://www.pluralsight.com/guides/introduction-to-the-fork-join-framework)