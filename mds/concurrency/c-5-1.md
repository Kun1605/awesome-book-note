# ReentrantLock

> 看本文之前，需要了解 [**AQS**](/mds/concurrency/c-5.md)。

ReentrantLock 是 AQS 同步框架的一个组件，是支持重进入的锁，意思就是任意线程在获取到锁之后能够再次获取该锁而不会被锁阻塞住。

既然说 ReentrantLock 是 AQS 的一个组件。那么它必然实现了 AQS 一部分方法。下面，我们来看一下具体代码实现。

## 1. Sync

Sync 是 ReentrantLock的一个内部静态抽象类，同时也继承了 AbstractQueuedSynchronizer。

![](/imgs/concurrency/c-5$1-1.png)

### 1.1 重写 - tryRelease(int)

从Sync重写了tryRelease(int) 方法可以看出，ReentrantLock是仅支持了独占式同步状态的获取与释放。

```java
/**
 * 释放资源
 * 每次state自减1
 */
protected final boolean tryRelease(int releases) {
    // 计算剩余锁的个数
    int c = getState() - releases;
    // 如果当前线程不是当前独占锁的线程，抛出异常
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    boolean free = false;

    // 如果剩余锁的个数为0，说明成功释放掉了锁
    if (c == 0) {
        free = true;
        // 将独占锁的线程设置为null
        setExclusiveOwnerThread(null);
    }
    // 更新state
    setState(c);
    return free;
}
```

### 1.2 公平锁与非公平锁

你或许会好奇，为什么没有重写tryAcquire这个方法？理由是，在ReentrantLock中将独占锁分为公平独占锁与非公平独占锁两种。

### ReentrantLock的特点

1. 线程再次获取锁。锁需要去识别获取锁的线程是否为当前占据锁的线程，如果是，则再次获取成功。

2. 锁的最终释放。线程重复n此获取了锁，随后在第n次释放该锁之后，其他线程才能够获取到这个锁。同一线程对于同一资源的重复获取，每获取一次，state进行自增；释放的时候，state进行自减。当state为0的时候，说明锁已经成功释放，其他线程可以尝试获取资源。

## 参考

##  [BACK](/summary.md)