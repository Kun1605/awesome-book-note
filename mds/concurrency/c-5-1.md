# ReentrantLock

> 看本文之前，需要了解 [**AQS**](/mds/concurrency/c-5.md)。

### 目录
-   [1. Sync](#user-content-aqs-1)
    -   [1.1 重写 - tryRelease(int)](#user-content-aqs-1-1)
    -   [1.2 公平锁与非公平锁](#user-content-aqs-1-2)
        -   [1.2.1 tryAcquire - 公平锁](#user-content-aqs-1-2-1)
        -   [1.2.2 tryAcquire - 非公平锁](#user-content-aqs-1-2-2)
        -   [1.2.3 公平锁与非公平锁之间的区别](#user-content-aqs-1-2-3)
    -   [1.3 ReentrantLock的特点](#user-content-aqs-1-3)
-   [2. 实战](#user-content-aqs-2)
    -   [2.1 lock() & unlock()](#user-content-aqs-2-1)
    -   [2.2 tryLock()](#user-content-aqs-2-2)
    -   [2.3 lockInterruptibly() & getHoldCount](#user-content-aqs-2-3)
-   [3. ReentrantLock 与 synchronized 区别](#user-content-aqs-3)

---

ReentrantLock 是 AQS 同步框架的一个组件，是支持重进入的锁，意思就是任意线程在获取到锁之后能够再次获取该锁而不会被锁阻塞住。

既然说 ReentrantLock 是 AQS 的一个组件。那么它必然实现了 AQS 一部分方法。下面，我们来看一下具体代码实现。

## <a id="aqs-1">1. Sync</a>

Sync 是 ReentrantLock的一个内部静态抽象类，同时也继承了 AbstractQueuedSynchronizer。

![](/imgs/concurrency/c-5$1-1.png)

### <a id="aqs-1-1">1.1 重写 - tryRelease(int)</a>

从Sync重写了tryRelease(int) 方法可以看出，ReentrantLock是仅支持了独占式同步状态的获取与释放。

```java
/**
 * 释放资源
 * 每次state自减1
 */
protected final boolean tryRelease(int releases) {
    // 计算拥有锁的线程个数
    int c = getState() - releases;
    // 如果当前线程不是当前独占锁的线程，抛出异常
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    boolean free = false;

    // 如果拥有锁的线程个数为0，说明成功释放掉了锁
    if (c == 0) {
        free = true;
        // 将独占锁的线程设置为null
        setExclusiveOwnerThread(null);
    }
    // 更新state
    setState(c);
    return free;
}
```

### <a id="aqs-1-2">1.2 公平锁与非公平锁</a>

你或许会好奇，为什么没有重写tryAcquire这个方法？理由是，在ReentrantLock中将独占锁分为 **公平独占锁** 与 **非公平独占锁** 两种。这两种锁才是 ReentrantLock 内部真正的锁。它们都各自实现了具体的 tryAcquire 方法。

#### <a id="aqs-1-2-1">1.2.1 tryAcquire - 公平锁</a>

```java
protected final boolean tryAcquire(int acquires) {
    // 获取当前线程
    final Thread current = Thread.currentThread();
    // 获取当前拥有锁的线程个数
    int c = getState();
    // 如果c==0，说明当前没有线程占有锁
    if (c == 0) {
        
        // hasQueuedPredecessors，判断同步队列中是否有线程在等待获取同步状态。如果不存在，尝试CAS 更新state值；否则，返回false
        if (!hasQueuedPredecessors() &&
            compareAndSetState(0, acquires)) {
            // 将当前拥有锁的线程设置为当前的线程
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    /**
     * 进入这个分支，说明当前有线程占有着锁
     * 判断当前拥有锁的线程是不是同一个线程，如果是，成功获取锁。
     */
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc < 0)
            throw new Error("Maximum lock count exceeded");
        // 更新state值
        setState(nextc);
        return true;
    }
    return false;
}
```

#### <a id="aqs-1-2-2">1.2.2 tryAcquire - 非公平锁</a>

```java
protected final boolean tryAcquire(int acquires) {
    return nonfairTryAcquire(acquires);
}
```

非公平锁中的 tryAcquire 实际上是调用了 Sync 中的 nonfairTryAcquire 方法。

```java
final boolean nonfairTryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) {
        if (compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc < 0) // overflow
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;
    }
    return false;
}
```

#### <a id="aqs-1-2-3">1.2.3 公平锁与非公平锁之间的区别</a>

从上面对公平锁与非公平锁的tryAcquire方法的分析，可以看出，两者唯一的区别就是在公平锁中增加了 hasQueuedPredecessors() 这个判断。

```java
public final boolean hasQueuedPredecessors() {
    // The correctness of this depends on head being initialized
    // before tail and on head.next being accurate if the current
    // thread is first in queue.
    Node t = tail; // Read fields in reverse initialization order
    Node h = head;
    Node s;
    return h != t &&
        ((s = h.next) == null || s.thread != Thread.currentThread());
}
```

hasQueuedPredecessors 判断了同步队列是否有线程等待获取同步状态。如果该方法返回true，说明除了当前线程之外没有存在其他线程存在于同步队列中。

而在非公平锁的 tryAcquire 中不需要关心同步队列中是否有其他线程正在等待获取同步状态，直接尝试 CAS 来更新同步状态。

### <a id="aqs-1-3">1.3 ReentrantLock的特点</a>

1. 线程再次获取锁。锁需要去识别获取锁的线程是否为当前占据锁的线程，如果是，则再次获取成功。

2. 锁的最终释放。线程重复n此获取了锁，随后在第n次释放该锁之后，其他线程才能够获取到这个锁。同一线程对于同一资源的重复获取，每获取一次，state进行自增；释放的时候，state进行自减。当state为0的时候，说明锁已经成功释放，其他线程可以尝试获取资源。

## 实战

了解过 [AQS](/mds/concurrency/c-5.md) 我们知道 ReentrantLock 是面向锁的使用者。前面讲了 ReentrantLock 的代码实现原理。下面我们以锁的使用者身份来看看，怎么使用 ReentrantLock 。

### <a id="aqs-2-1">2.1 lock() & unlock()</a>

如下面的代码所示，ReentryLock 通常是与 **try/finally** 配合一起使用的：

```java
public void anyMethod() {
   reentrantLock.lock();
   try {
       //perform task
   }finally {
       reentrantLock.unlock();
   }    
} 
```

unlock 始终在 finally 语句块中被调用，如果在方法体中有异常抛出，可以确保锁能够被及时释放。

**Task**

```java
public interface Task {
	void  performTask();
}
```

**LockUnlockDemo.java**

```java
public class LockUnlockDemo implements Task{

	final ReentrantLock lock = new ReentrantLock();
	
	public void performTask() {
		lock.lock();
		
		try {
			System.out.println(Thread.currentThread().getName() + " : Lock acquired.");
			System.out.println("Processing...");
			TimeUnit.SECONDS.sleep(2);
		} catch (InterruptedException e) {
			e.printStackTrace();
		} finally {
			System.out.println(Thread.currentThread().getName() + " : Lock release.");
			lock.unlock();
		}
	}
}
```

**Worker.java**

```java
public class Worker implements Runnable {

	private Task task;
	
	public Worker(Task task) {
		this.task = task;
	}

	@Override
	public void run() {
		task.performTask();
	}

}
```

**ConcurrencyTest.java**

```java
public class ConcurrencyTest {

	private static final int MAX_THREADS = 5;
	private static final ExecutorService EXECUTOR_SERVICE = Executors.newFixedThreadPool(MAX_THREADS);
	
	public static void main(String[] args) {
		Task task = new LockUnlockDemo();
		for(int i = 0; i<MAX_THREADS; i++) {
			EXECUTOR_SERVICE.execute(new Worker(task));
		}
		
		EXECUTOR_SERVICE.shutdown();
	}
}
```

结果输出：

> pool-1-thread-1 : Lock acquired.
Processing...   
pool-1-thread-1 : Lock release.     
pool-1-thread-2 : Lock acquired.        
Processing...   
pool-1-thread-2 : Lock release.     
pool-1-thread-3 : Lock acquired.    
Processing...   
pool-1-thread-3 : Lock release.     
pool-1-thread-4 : Lock acquired.        
Processing...
pool-1-thread-4 : Lock release. 
pool-1-thread-5 : Lock acquired.    
Processing...   
pool-1-thread-5 : Lock release.

### <a id="aqs-2-2">2.2 tryLock()</a>

**TryLockDemo.java**

```java
public class TryLockDemo implements Task {
	final ReentrantLock lock = new ReentrantLock();
	
	@Override
	public void performTask() {
		try {
			boolean flag = lock.tryLock(100, TimeUnit.SECONDS);
			
			if(flag) {
				try {
					System.out.println(Thread.currentThread().getName() + " : Lock acquired.");
					System.out.println("Performing task... ...");
				} finally {
					System.out.println(Thread.currentThread().getName() + " : Lock released.");
					lock.unlock();
				}
			}
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

}
```

在 ConcurrencyTest.java 中将 LockUnlockDemo 改成 TryLockDemo：

```java
final Task task = new TryLockDemo();
```

结果如下：

> pool-1-thread-1 : Lock acquired.  
Performing task... ...  
pool-1-thread-1 : Lock released.    
pool-1-thread-3 : Lock acquired.    
Performing task... ...  
pool-1-thread-3 : Lock released.    
pool-1-thread-2 : Lock acquired.    
Performing task... ...  
pool-1-thread-2 : Lock released.    
pool-1-thread-4 : Lock acquired.    
Performing task... ...  
pool-1-thread-4 : Lock released.    
pool-1-thread-5 : Lock acquired.    
Performing task... ...  
pool-1-thread-5 : Lock released.

相比较上面的 lock ，可以发现 tryLock 的结果并不是按照期望的顺序打印出来。

## 参考

-   《Java并发编程的艺术 - 第五章》
-   [Java Lock Example – ReentrantLock](https://www.journaldev.com/2377/java-lock-example-reentrantlock)
-   [ReentrantLock Java Example](https://www.concretepage.com/java/reentrantlock-java-example-with-lock-unlock-trylock-lockinterruptibly-isheldbycurrentthread-and-getholdcount)
-   [ReentrantLock Example in Java, Difference between synchronized vs ReentrantLock](https://javarevisited.blogspot.com/2013/03/reentrantlock-example-in-java-synchronized-difference-vs-lock.html)

##  [BACK](/summary.md)