# AbstractQueuedSynchronizer

> 参阅版本号: JDK7

## 目录
-   [AQS 是什么？](#user-content-aqs-1)
    -   [锁与同步器之间的关系](#user-content-aqs-1-1)
-   [AQS 提供的接口与模板方法介绍](#user-content-aqs-2)
    -   [AQS 提供的接口](#user-content-aqs-2-1)
    -   [AQS 提供的模板方法](#user-content-aqs-2-2)
-   [AQS 的代码实现](#user-content-aqs-3)
-   LockSupport


## <a id="aqs-1">AQS 是什么？</a>

**AbstractQueuedSynchronizer** (下面简称AQS或同步器)是分析 **java.util.concurrency** 源码所必须要了解的一个类。 AQS 是用来构建锁或者其他同步组件的 **基础框架**，例如 **ReentranLock**、**ReadWriteLock**、**Semaphore**等。

AQS 是通过内置的 **FIFO队列** (FIRST IN FIRST OUT)来完成资源在各个线程之间的分配工作，即决定了哪些线程能够获取资源，哪些线程处于等待、中断或者退出等待等状态。

### <a id="aqs-1-1">锁与同步器之间的关系</a>

-   锁是面向 **使用者**。它定义了使用者与锁交互的接口(比如可以允许两个线程并行访问)，隐藏了实现细节。
-   同步器是面向 **实现者**。它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等 **底层操作**。

## <a id="aqs-2">AQS 提供的接口与模板方法介绍</a>

AQS 是基于 [模板方法](/mds/design-model/ds-behavior-0.md) 模式来设计的。AQS 为锁的实现者们暴露了一些接口和模板方法。下面来看一下 AQS 为我们提供了哪些接口和模板方法。

### <a id="aqs-2-1">AQS 提供的接口</a>

![](/imgs/concurrency/c-5-1.png)

就暴露出了5个可重写的接口，不实现将会抛出 **`UnsupportedOperationException`**。

```java
protected boolean tryAcquire(int arg) {
    throw new UnsupportedOperationException();
}
protected boolean tryRelease(int arg) {
        throw new UnsupportedOperationException();
}
protected int tryAcquireShared(int arg) {
    throw new UnsupportedOperationException();
}
protected boolean tryReleaseShared(int arg) {
    throw new UnsupportedOperationException();
}
protected boolean isHeldExclusively() {
    throw new UnsupportedOperationException();
}
```

| 方法名 | 作用 |
| :--: | :--: |
| protected boolean tryAcquire(int arg) | **独占式获取同步状态** |
| protected boolean tryRelease(int arg) | **独占式释放同步状态** |
| protected int tryAcquireShared(int arg) | **共享式获取同步状态** |
| protected boolean tryReleaseShared(int arg) | **共享式释放同步状态**|
| protected boolean isHeldExclusively() | 判断当前同步器是否在 **独占模式** 下被线程占用 |

### <a id="aqs-2-2">AQS 提供的模板方法</a>

AQS 提供的模板方法主要分为 **3** 类：

-   独占式获取与释放同步状态
-   共享式获取与释放同步状态
-   查询同步队列中的等待线程情况

下面罗列出部分的模板方法：

| 方法名 | 作用 |
| :--: | :--: |
| public final void acquire(int arg) | 独占式获取同步状态,对中断不敏感(具体请看后面的详解)。如果当前线程获取同步状态成功，则由这个方法返回；否则，将会进入同步队列等待。 |
| public final void acquireInterruptibly(int arg) throws InterruptedException | 与 **acquire(int arg)** 作用相同都是独占式获取同步状态，但是这个方法是响应中断。这个方法在下面2种情况能够返回：1. 成功获取同步状态；2. 当前线程被中断，抛出异常退出。 |
| public final **boolean** tryAcquireNanos(int arg, long nanosTimeout) throws InterruptedException | 在 **acquireInterruptibly(int arg)** 的基础上加上了时间限制。这个方法在下面3种情况能够返回：1. 在规定的时间内获取同步状态，返回 **true**；2. 当前线程被中断，抛出异常退出；3. 获取同步状态超时，返回 **false**。 |
| public final **boolean** release(int arg) | 独占式释放同步状态。成功释放，返回 **true**；否则，返回 **false**。 |
| public final void acquireShared(int arg) | 共享式获取同步状态，对中断不敏感。如果当前线程未获取到同步状态，将会进入到同步队列等待。与 **独占式** 获取同步状态的主要区别是在同一时刻可以有多个线程获取到同步状态。 |
| public final void acquireSharedInterruptibly(int arg) throws InterruptedException | 与 **acquireShared(int arg)** 作用相同都是共享式获取同步状态，同时，增加了响应线程中断。 |
| public final **boolean** tryAcquireSharedNanos(int arg, long nanosTimeout) throws InterruptedException | 在 **acquireSharedInterruptibly(int arg)** 的基础上加上了时间限制。 |
| public final **boolean** releaseShared(int arg) | 共享式释放同步状态。成功释放，返回 **true**；否则，返回 **false**。 |

## <a id="aqs-3">AQS 的代码实现</a>

前面讲了 AQS 的各种功能，下面我们从代码实现来看看同步器是如何完成线程同步的。

![](/imgs/concurrency/c-5-1.svg)

##   参考
-   《Java并发编程的艺术 - 第五章》

## [Back](../../summary.md)