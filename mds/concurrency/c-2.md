# HashMap

-   [JDK1.7](#user-content-jdk7)
-   [JDK1.8](#user-content-jdk7)

## <a id="jdk7">JDK1.7</a>

### 结构

![](/imgs/concurrency/c-2-1.png)

-   HashMap 里面是一个数组，然后数组中每个元素是一个单向链表。
-   每个绿色的实体是嵌套类 Entry 的实例，Entry 包含四个属性：key, value, hash 值和用于单向链表的 next。

### HashMap 初始化

```java
//初始容量为2的倍数，这里是16
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4;

static final float DEFAULT_LOAD_FACTOR = 0.75f;

public HashMap() {
    this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);
}

public HashMap(int initialCapacity, float loadFactor) {
    if (initialCapacity < 0)
        throw new IllegalArgumentException("Illegal initial capacity: " +
                                            initialCapacity);
    if (initialCapacity > MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    if (loadFactor <= 0 || Float.isNaN(loadFactor))
        throw new IllegalArgumentException("Illegal load factor: " +
                                            loadFactor);

    //初始化负载因子
    this.loadFactor = loadFactor;
    //初始化扩容阈值
    threshold = initialCapacity;
    init();
}
```

上面只是对负载因子和阈值的初始化，对Map的初始化是在 **put(K, V)**里面进行的。

```java
public V put(K key, V value) {
    if (table == EMPTY_TABLE) {
        inflateTable(threshold);
    }
    if (key == null)
        return putForNullKey(value);
    //对键值进行散列
    int hash = hash(key);
    //根据散列值和数组的长度来计算当前Key对应的数组下标
    int i = indexFor(hash, table.length);
    for (Entry<K,V> e = table[i]; e != null; e = e.next) {
        Object k;
        if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {
            V oldValue = e.value;
            e.value = value;
            e.recordAccess(this);
            return oldValue;
        }
    }

    modCount++;
    addEntry(hash, key, value, i);
    return null;
}
```

在第一个元素插入 HashMap 的时候做一次数组的初始化，就是先确定初始的数组大小，并计算数组扩容的阈值。

```java
 private void inflateTable(int toSize) {
    //将容量设置为2的N次方
    int capacity = roundUpToPowerOf2(toSize);
    //计算扩容阈值
    threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);
    table = new Entry[capacity];
    initHashSeedAsNeeded(capacity);
}
```

### 计算Key对应的下标 

```java
static int indexFor(int h, int length) {
    // assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2";
    return h & (length-1);
}
```

这个方法很简单，简单说就是取 hash 值的低 n 位。这里就是利用了数组的容量都是2的N次方倍的好处。如在数组长度为 32 的时候，其实取的就是 key 的 hash 值的低 5 位，作为它在数组中的下标位置。

### 添加节点到链表中

```java
void addEntry(int hash, K key, V value, int bucketIndex) {
    //如果当前HashMap的大小 >= 阈值，并且当前Key对应的数组下标不为null，就进行扩容。
    if ((size >= threshold) && (null != table[bucketIndex])) {
        //将table的容量扩大为原来的2倍，再将原来的节点重新计算下标放入新的table内
        resize(2 * table.length);
        //计算当前key的hash
        hash = (null != key) ? hash(key) : 0;
        //计算key对应的数组下标
        bucketIndex = indexFor(hash, table.length);
    }
    //创建节点
    createEntry(hash, key, value, bucketIndex);
}

//将新值放到表头，然后size++
void createEntry(int hash, K key, V value, int bucketIndex) {
    Entry<K,V> e = table[bucketIndex];
    table[bucketIndex] = new Entry<>(hash, key, value, e);
    size++;
}
```

### 扩容

```java
void resize(int newCapacity) {
    Entry[] oldTable = table;
    int oldCapacity = oldTable.length;
    if (oldCapacity == MAXIMUM_CAPACITY) {
        threshold = Integer.MAX_VALUE;
        return;
    }

    Entry[] newTable = new Entry[newCapacity];
    transfer(newTable, initHashSeedAsNeeded(newCapacity));
    table = newTable;
    threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);
}
```

## <a id="jdk8">JDK1.8</a>

## 总结

-   HashMap是非线程安全的。
-   HashMap每次扩容的时候，新的容器容量为旧的容器的 **2** 倍。
-   HashMap在

##   参考
-   [importnew](http://www.importnew.com/28263.html)
-   [程序员小灰](https://mp.weixin.qq.com/s/Z_3y65esVZH7G5OHc7_7WQ)
-   [酷壳](https://coolshell.cn/articles/9606.html)

## [Back](../../summary.md)